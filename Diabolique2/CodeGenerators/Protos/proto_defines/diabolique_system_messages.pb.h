// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto_defines/diabolique_system_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto {
  static const uint32_t offsets[];
};
class create_module;
struct create_moduleDefaultTypeInternal;
extern create_moduleDefaultTypeInternal _create_module_default_instance_;
class exit_process;
struct exit_processDefaultTypeInternal;
extern exit_processDefaultTypeInternal _exit_process_default_instance_;
class file_server_request;
struct file_server_requestDefaultTypeInternal;
extern file_server_requestDefaultTypeInternal _file_server_request_default_instance_;
class file_transfer_segment;
struct file_transfer_segmentDefaultTypeInternal;
extern file_transfer_segmentDefaultTypeInternal _file_transfer_segment_default_instance_;
class file_transfer_server_segment;
struct file_transfer_server_segmentDefaultTypeInternal;
extern file_transfer_server_segmentDefaultTypeInternal _file_transfer_server_segment_default_instance_;
class initialize_module;
struct initialize_moduleDefaultTypeInternal;
extern initialize_moduleDefaultTypeInternal _initialize_module_default_instance_;
class kill_instance;
struct kill_instanceDefaultTypeInternal;
extern kill_instanceDefaultTypeInternal _kill_instance_default_instance_;
class machine_information;
struct machine_informationDefaultTypeInternal;
extern machine_informationDefaultTypeInternal _machine_information_default_instance_;
class module_creation_result;
struct module_creation_resultDefaultTypeInternal;
extern module_creation_resultDefaultTypeInternal _module_creation_result_default_instance_;
class module_message;
struct module_messageDefaultTypeInternal;
extern module_messageDefaultTypeInternal _module_message_default_instance_;
class screen_capture;
struct screen_captureDefaultTypeInternal;
extern screen_captureDefaultTypeInternal _screen_capture_default_instance_;
class screen_capture_startup;
struct screen_capture_startupDefaultTypeInternal;
extern screen_capture_startupDefaultTypeInternal _screen_capture_startup_default_instance_;
class server_notify_disconnect;
struct server_notify_disconnectDefaultTypeInternal;
extern server_notify_disconnectDefaultTypeInternal _server_notify_disconnect_default_instance_;
class task_sig_end;
struct task_sig_endDefaultTypeInternal;
extern task_sig_endDefaultTypeInternal _task_sig_end_default_instance_;
class task_startup;
struct task_startupDefaultTypeInternal;
extern task_startupDefaultTypeInternal _task_startup_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::create_module* Arena::CreateMaybeMessage<::create_module>(Arena*);
template<> ::exit_process* Arena::CreateMaybeMessage<::exit_process>(Arena*);
template<> ::file_server_request* Arena::CreateMaybeMessage<::file_server_request>(Arena*);
template<> ::file_transfer_segment* Arena::CreateMaybeMessage<::file_transfer_segment>(Arena*);
template<> ::file_transfer_server_segment* Arena::CreateMaybeMessage<::file_transfer_server_segment>(Arena*);
template<> ::initialize_module* Arena::CreateMaybeMessage<::initialize_module>(Arena*);
template<> ::kill_instance* Arena::CreateMaybeMessage<::kill_instance>(Arena*);
template<> ::machine_information* Arena::CreateMaybeMessage<::machine_information>(Arena*);
template<> ::module_creation_result* Arena::CreateMaybeMessage<::module_creation_result>(Arena*);
template<> ::module_message* Arena::CreateMaybeMessage<::module_message>(Arena*);
template<> ::screen_capture* Arena::CreateMaybeMessage<::screen_capture>(Arena*);
template<> ::screen_capture_startup* Arena::CreateMaybeMessage<::screen_capture_startup>(Arena*);
template<> ::server_notify_disconnect* Arena::CreateMaybeMessage<::server_notify_disconnect>(Arena*);
template<> ::task_sig_end* Arena::CreateMaybeMessage<::task_sig_end>(Arena*);
template<> ::task_startup* Arena::CreateMaybeMessage<::task_startup>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class module_message final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:module_message) */ {
 public:
  inline module_message() : module_message(nullptr) {}
  ~module_message() override;
  explicit PROTOBUF_CONSTEXPR module_message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  module_message(const module_message& from);
  module_message(module_message&& from) noexcept
    : module_message() {
    *this = ::std::move(from);
  }

  inline module_message& operator=(const module_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline module_message& operator=(module_message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const module_message& default_instance() {
    return *internal_default_instance();
  }
  static inline const module_message* internal_default_instance() {
    return reinterpret_cast<const module_message*>(
               &_module_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(module_message& a, module_message& b) {
    a.Swap(&b);
  }
  inline void Swap(module_message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(module_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  module_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<module_message>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const module_message& from);
  void MergeFrom(const module_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(module_message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "module_message";
  }
  protected:
  explicit module_message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kModuleIndexFieldNumber = 2,
  };
  // required bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required int32 module_index = 2;
  bool has_module_index() const;
  private:
  bool _internal_has_module_index() const;
  public:
  void clear_module_index();
  int32_t module_index() const;
  void set_module_index(int32_t value);
  private:
  int32_t _internal_module_index() const;
  void _internal_set_module_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:module_message)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t module_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class create_module final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:create_module) */ {
 public:
  inline create_module() : create_module(nullptr) {}
  ~create_module() override;
  explicit PROTOBUF_CONSTEXPR create_module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  create_module(const create_module& from);
  create_module(create_module&& from) noexcept
    : create_module() {
    *this = ::std::move(from);
  }

  inline create_module& operator=(const create_module& from) {
    CopyFrom(from);
    return *this;
  }
  inline create_module& operator=(create_module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const create_module& default_instance() {
    return *internal_default_instance();
  }
  static inline const create_module* internal_default_instance() {
    return reinterpret_cast<const create_module*>(
               &_create_module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(create_module& a, create_module& b) {
    a.Swap(&b);
  }
  inline void Swap(create_module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(create_module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  create_module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<create_module>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const create_module& from);
  void MergeFrom(const create_module& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(create_module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "create_module";
  }
  protected:
  explicit create_module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:create_module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class initialize_module final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:initialize_module) */ {
 public:
  inline initialize_module() : initialize_module(nullptr) {}
  ~initialize_module() override;
  explicit PROTOBUF_CONSTEXPR initialize_module(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  initialize_module(const initialize_module& from);
  initialize_module(initialize_module&& from) noexcept
    : initialize_module() {
    *this = ::std::move(from);
  }

  inline initialize_module& operator=(const initialize_module& from) {
    CopyFrom(from);
    return *this;
  }
  inline initialize_module& operator=(initialize_module&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const initialize_module& default_instance() {
    return *internal_default_instance();
  }
  static inline const initialize_module* internal_default_instance() {
    return reinterpret_cast<const initialize_module*>(
               &_initialize_module_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(initialize_module& a, initialize_module& b) {
    a.Swap(&b);
  }
  inline void Swap(initialize_module* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(initialize_module* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  initialize_module* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<initialize_module>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const initialize_module& from);
  void MergeFrom(const initialize_module& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(initialize_module* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "initialize_module";
  }
  protected:
  explicit initialize_module(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitDataFieldNumber = 2,
    kModuleIndexFieldNumber = 1,
  };
  // optional bytes init_data = 2;
  bool has_init_data() const;
  private:
  bool _internal_has_init_data() const;
  public:
  void clear_init_data();
  const std::string& init_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_init_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_init_data();
  PROTOBUF_NODISCARD std::string* release_init_data();
  void set_allocated_init_data(std::string* init_data);
  private:
  const std::string& _internal_init_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init_data(const std::string& value);
  std::string* _internal_mutable_init_data();
  public:

  // required int32 module_index = 1;
  bool has_module_index() const;
  private:
  bool _internal_has_module_index() const;
  public:
  void clear_module_index();
  int32_t module_index() const;
  void set_module_index(int32_t value);
  private:
  int32_t _internal_module_index() const;
  void _internal_set_module_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:initialize_module)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_data_;
    int32_t module_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class module_creation_result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:module_creation_result) */ {
 public:
  inline module_creation_result() : module_creation_result(nullptr) {}
  ~module_creation_result() override;
  explicit PROTOBUF_CONSTEXPR module_creation_result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  module_creation_result(const module_creation_result& from);
  module_creation_result(module_creation_result&& from) noexcept
    : module_creation_result() {
    *this = ::std::move(from);
  }

  inline module_creation_result& operator=(const module_creation_result& from) {
    CopyFrom(from);
    return *this;
  }
  inline module_creation_result& operator=(module_creation_result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const module_creation_result& default_instance() {
    return *internal_default_instance();
  }
  static inline const module_creation_result* internal_default_instance() {
    return reinterpret_cast<const module_creation_result*>(
               &_module_creation_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(module_creation_result& a, module_creation_result& b) {
    a.Swap(&b);
  }
  inline void Swap(module_creation_result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(module_creation_result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  module_creation_result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<module_creation_result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const module_creation_result& from);
  void MergeFrom(const module_creation_result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(module_creation_result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "module_creation_result";
  }
  protected:
  explicit module_creation_result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailureFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  // required bool failure = 1;
  bool has_failure() const;
  private:
  bool _internal_has_failure() const;
  public:
  void clear_failure();
  bool failure() const;
  void set_failure(bool value);
  private:
  bool _internal_failure() const;
  void _internal_set_failure(bool value);
  public:

  // optional int32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional int32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:module_creation_result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool failure_;
    int32_t type_;
    int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class machine_information final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:machine_information) */ {
 public:
  inline machine_information() : machine_information(nullptr) {}
  ~machine_information() override;
  explicit PROTOBUF_CONSTEXPR machine_information(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  machine_information(const machine_information& from);
  machine_information(machine_information&& from) noexcept
    : machine_information() {
    *this = ::std::move(from);
  }

  inline machine_information& operator=(const machine_information& from) {
    CopyFrom(from);
    return *this;
  }
  inline machine_information& operator=(machine_information&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const machine_information& default_instance() {
    return *internal_default_instance();
  }
  static inline const machine_information* internal_default_instance() {
    return reinterpret_cast<const machine_information*>(
               &_machine_information_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(machine_information& a, machine_information& b) {
    a.Swap(&b);
  }
  inline void Swap(machine_information* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(machine_information* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  machine_information* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<machine_information>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const machine_information& from);
  void MergeFrom(const machine_information& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(machine_information* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "machine_information";
  }
  protected:
  explicit machine_information(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kLocalipFieldNumber = 2,
    kExternalipFieldNumber = 3,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string localip = 2;
  bool has_localip() const;
  private:
  bool _internal_has_localip() const;
  public:
  void clear_localip();
  const std::string& localip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localip();
  PROTOBUF_NODISCARD std::string* release_localip();
  void set_allocated_localip(std::string* localip);
  private:
  const std::string& _internal_localip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localip(const std::string& value);
  std::string* _internal_mutable_localip();
  public:

  // optional string externalip = 3;
  bool has_externalip() const;
  private:
  bool _internal_has_externalip() const;
  public:
  void clear_externalip();
  const std::string& externalip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_externalip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_externalip();
  PROTOBUF_NODISCARD std::string* release_externalip();
  void set_allocated_externalip(std::string* externalip);
  private:
  const std::string& _internal_externalip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_externalip(const std::string& value);
  std::string* _internal_mutable_externalip();
  public:

  // @@protoc_insertion_point(class_scope:machine_information)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr externalip_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class screen_capture final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:screen_capture) */ {
 public:
  inline screen_capture() : screen_capture(nullptr) {}
  ~screen_capture() override;
  explicit PROTOBUF_CONSTEXPR screen_capture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  screen_capture(const screen_capture& from);
  screen_capture(screen_capture&& from) noexcept
    : screen_capture() {
    *this = ::std::move(from);
  }

  inline screen_capture& operator=(const screen_capture& from) {
    CopyFrom(from);
    return *this;
  }
  inline screen_capture& operator=(screen_capture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const screen_capture& default_instance() {
    return *internal_default_instance();
  }
  static inline const screen_capture* internal_default_instance() {
    return reinterpret_cast<const screen_capture*>(
               &_screen_capture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(screen_capture& a, screen_capture& b) {
    a.Swap(&b);
  }
  inline void Swap(screen_capture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(screen_capture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  screen_capture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<screen_capture>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const screen_capture& from);
  void MergeFrom(const screen_capture& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(screen_capture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "screen_capture";
  }
  protected:
  explicit screen_capture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // required bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:screen_capture)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t width_;
    int32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class screen_capture_startup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:screen_capture_startup) */ {
 public:
  inline screen_capture_startup() : screen_capture_startup(nullptr) {}
  ~screen_capture_startup() override;
  explicit PROTOBUF_CONSTEXPR screen_capture_startup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  screen_capture_startup(const screen_capture_startup& from);
  screen_capture_startup(screen_capture_startup&& from) noexcept
    : screen_capture_startup() {
    *this = ::std::move(from);
  }

  inline screen_capture_startup& operator=(const screen_capture_startup& from) {
    CopyFrom(from);
    return *this;
  }
  inline screen_capture_startup& operator=(screen_capture_startup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const screen_capture_startup& default_instance() {
    return *internal_default_instance();
  }
  static inline const screen_capture_startup* internal_default_instance() {
    return reinterpret_cast<const screen_capture_startup*>(
               &_screen_capture_startup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(screen_capture_startup& a, screen_capture_startup& b) {
    a.Swap(&b);
  }
  inline void Swap(screen_capture_startup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(screen_capture_startup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  screen_capture_startup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<screen_capture_startup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const screen_capture_startup& from);
  void MergeFrom(const screen_capture_startup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(screen_capture_startup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "screen_capture_startup";
  }
  protected:
  explicit screen_capture_startup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicksBetweenFieldNumber = 1,
  };
  // required int32 ticks_between = 1;
  bool has_ticks_between() const;
  private:
  bool _internal_has_ticks_between() const;
  public:
  void clear_ticks_between();
  int32_t ticks_between() const;
  void set_ticks_between(int32_t value);
  private:
  int32_t _internal_ticks_between() const;
  void _internal_set_ticks_between(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:screen_capture_startup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t ticks_between_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class task_startup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:task_startup) */ {
 public:
  inline task_startup() : task_startup(nullptr) {}
  ~task_startup() override;
  explicit PROTOBUF_CONSTEXPR task_startup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  task_startup(const task_startup& from);
  task_startup(task_startup&& from) noexcept
    : task_startup() {
    *this = ::std::move(from);
  }

  inline task_startup& operator=(const task_startup& from) {
    CopyFrom(from);
    return *this;
  }
  inline task_startup& operator=(task_startup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const task_startup& default_instance() {
    return *internal_default_instance();
  }
  static inline const task_startup* internal_default_instance() {
    return reinterpret_cast<const task_startup*>(
               &_task_startup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(task_startup& a, task_startup& b) {
    a.Swap(&b);
  }
  inline void Swap(task_startup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(task_startup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  task_startup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<task_startup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const task_startup& from);
  void MergeFrom(const task_startup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(task_startup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_startup";
  }
  protected:
  explicit task_startup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskNumberFieldNumber = 1,
  };
  // required int32 task_number = 1;
  bool has_task_number() const;
  private:
  bool _internal_has_task_number() const;
  public:
  void clear_task_number();
  int32_t task_number() const;
  void set_task_number(int32_t value);
  private:
  int32_t _internal_task_number() const;
  void _internal_set_task_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:task_startup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t task_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class task_sig_end final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:task_sig_end) */ {
 public:
  inline task_sig_end() : task_sig_end(nullptr) {}
  ~task_sig_end() override;
  explicit PROTOBUF_CONSTEXPR task_sig_end(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  task_sig_end(const task_sig_end& from);
  task_sig_end(task_sig_end&& from) noexcept
    : task_sig_end() {
    *this = ::std::move(from);
  }

  inline task_sig_end& operator=(const task_sig_end& from) {
    CopyFrom(from);
    return *this;
  }
  inline task_sig_end& operator=(task_sig_end&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const task_sig_end& default_instance() {
    return *internal_default_instance();
  }
  static inline const task_sig_end* internal_default_instance() {
    return reinterpret_cast<const task_sig_end*>(
               &_task_sig_end_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(task_sig_end& a, task_sig_end& b) {
    a.Swap(&b);
  }
  inline void Swap(task_sig_end* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(task_sig_end* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  task_sig_end* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<task_sig_end>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const task_sig_end& from);
  void MergeFrom(const task_sig_end& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(task_sig_end* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_sig_end";
  }
  protected:
  explicit task_sig_end(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskEndFieldNumber = 1,
  };
  // required int32 task_end = 1;
  bool has_task_end() const;
  private:
  bool _internal_has_task_end() const;
  public:
  void clear_task_end();
  int32_t task_end() const;
  void set_task_end(int32_t value);
  private:
  int32_t _internal_task_end() const;
  void _internal_set_task_end(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:task_sig_end)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t task_end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class exit_process final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:exit_process) */ {
 public:
  inline exit_process() : exit_process(nullptr) {}
  ~exit_process() override;
  explicit PROTOBUF_CONSTEXPR exit_process(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  exit_process(const exit_process& from);
  exit_process(exit_process&& from) noexcept
    : exit_process() {
    *this = ::std::move(from);
  }

  inline exit_process& operator=(const exit_process& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_process& operator=(exit_process&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const exit_process& default_instance() {
    return *internal_default_instance();
  }
  static inline const exit_process* internal_default_instance() {
    return reinterpret_cast<const exit_process*>(
               &_exit_process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(exit_process& a, exit_process& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_process* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(exit_process* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  exit_process* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<exit_process>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const exit_process& from);
  void MergeFrom(const exit_process& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(exit_process* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "exit_process";
  }
  protected:
  explicit exit_process(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:exit_process)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class kill_instance final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kill_instance) */ {
 public:
  inline kill_instance() : kill_instance(nullptr) {}
  ~kill_instance() override;
  explicit PROTOBUF_CONSTEXPR kill_instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  kill_instance(const kill_instance& from);
  kill_instance(kill_instance&& from) noexcept
    : kill_instance() {
    *this = ::std::move(from);
  }

  inline kill_instance& operator=(const kill_instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline kill_instance& operator=(kill_instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const kill_instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const kill_instance* internal_default_instance() {
    return reinterpret_cast<const kill_instance*>(
               &_kill_instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(kill_instance& a, kill_instance& b) {
    a.Swap(&b);
  }
  inline void Swap(kill_instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(kill_instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  kill_instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<kill_instance>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const kill_instance& from);
  void MergeFrom(const kill_instance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(kill_instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kill_instance";
  }
  protected:
  explicit kill_instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kill_instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class server_notify_disconnect final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:server_notify_disconnect) */ {
 public:
  inline server_notify_disconnect() : server_notify_disconnect(nullptr) {}
  ~server_notify_disconnect() override;
  explicit PROTOBUF_CONSTEXPR server_notify_disconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  server_notify_disconnect(const server_notify_disconnect& from);
  server_notify_disconnect(server_notify_disconnect&& from) noexcept
    : server_notify_disconnect() {
    *this = ::std::move(from);
  }

  inline server_notify_disconnect& operator=(const server_notify_disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline server_notify_disconnect& operator=(server_notify_disconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const server_notify_disconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const server_notify_disconnect* internal_default_instance() {
    return reinterpret_cast<const server_notify_disconnect*>(
               &_server_notify_disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(server_notify_disconnect& a, server_notify_disconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(server_notify_disconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(server_notify_disconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  server_notify_disconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<server_notify_disconnect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const server_notify_disconnect& from);
  void MergeFrom(const server_notify_disconnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(server_notify_disconnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server_notify_disconnect";
  }
  protected:
  explicit server_notify_disconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:server_notify_disconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class file_transfer_segment final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:file_transfer_segment) */ {
 public:
  inline file_transfer_segment() : file_transfer_segment(nullptr) {}
  ~file_transfer_segment() override;
  explicit PROTOBUF_CONSTEXPR file_transfer_segment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  file_transfer_segment(const file_transfer_segment& from);
  file_transfer_segment(file_transfer_segment&& from) noexcept
    : file_transfer_segment() {
    *this = ::std::move(from);
  }

  inline file_transfer_segment& operator=(const file_transfer_segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline file_transfer_segment& operator=(file_transfer_segment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const file_transfer_segment& default_instance() {
    return *internal_default_instance();
  }
  static inline const file_transfer_segment* internal_default_instance() {
    return reinterpret_cast<const file_transfer_segment*>(
               &_file_transfer_segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(file_transfer_segment& a, file_transfer_segment& b) {
    a.Swap(&b);
  }
  inline void Swap(file_transfer_segment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(file_transfer_segment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  file_transfer_segment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<file_transfer_segment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const file_transfer_segment& from);
  void MergeFrom(const file_transfer_segment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(file_transfer_segment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "file_transfer_segment";
  }
  protected:
  explicit file_transfer_segment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 4,
    kFileSizeFieldNumber = 2,
    kPosFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required int32 file_size = 2;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  int32_t file_size() const;
  void set_file_size(int32_t value);
  private:
  int32_t _internal_file_size() const;
  void _internal_set_file_size(int32_t value);
  public:

  // required int32 pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  int32_t pos() const;
  void set_pos(int32_t value);
  private:
  int32_t _internal_pos() const;
  void _internal_set_pos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:file_transfer_segment)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t file_size_;
    int32_t pos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class file_transfer_server_segment final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:file_transfer_server_segment) */ {
 public:
  inline file_transfer_server_segment() : file_transfer_server_segment(nullptr) {}
  ~file_transfer_server_segment() override;
  explicit PROTOBUF_CONSTEXPR file_transfer_server_segment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  file_transfer_server_segment(const file_transfer_server_segment& from);
  file_transfer_server_segment(file_transfer_server_segment&& from) noexcept
    : file_transfer_server_segment() {
    *this = ::std::move(from);
  }

  inline file_transfer_server_segment& operator=(const file_transfer_server_segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline file_transfer_server_segment& operator=(file_transfer_server_segment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const file_transfer_server_segment& default_instance() {
    return *internal_default_instance();
  }
  static inline const file_transfer_server_segment* internal_default_instance() {
    return reinterpret_cast<const file_transfer_server_segment*>(
               &_file_transfer_server_segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(file_transfer_server_segment& a, file_transfer_server_segment& b) {
    a.Swap(&b);
  }
  inline void Swap(file_transfer_server_segment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(file_transfer_server_segment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  file_transfer_server_segment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<file_transfer_server_segment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const file_transfer_server_segment& from);
  void MergeFrom(const file_transfer_server_segment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(file_transfer_server_segment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "file_transfer_server_segment";
  }
  protected:
  explicit file_transfer_server_segment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropPathFieldNumber = 2,
    kFileFieldNumber = 1,
  };
  // required string drop_path = 2;
  bool has_drop_path() const;
  private:
  bool _internal_has_drop_path() const;
  public:
  void clear_drop_path();
  const std::string& drop_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_drop_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_drop_path();
  PROTOBUF_NODISCARD std::string* release_drop_path();
  void set_allocated_drop_path(std::string* drop_path);
  private:
  const std::string& _internal_drop_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_drop_path(const std::string& value);
  std::string* _internal_mutable_drop_path();
  public:

  // required .file_transfer_segment file = 1;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::file_transfer_segment& file() const;
  PROTOBUF_NODISCARD ::file_transfer_segment* release_file();
  ::file_transfer_segment* mutable_file();
  void set_allocated_file(::file_transfer_segment* file);
  private:
  const ::file_transfer_segment& _internal_file() const;
  ::file_transfer_segment* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::file_transfer_segment* file);
  ::file_transfer_segment* unsafe_arena_release_file();

  // @@protoc_insertion_point(class_scope:file_transfer_server_segment)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr drop_path_;
    ::file_transfer_segment* file_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class file_server_request final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:file_server_request) */ {
 public:
  inline file_server_request() : file_server_request(nullptr) {}
  ~file_server_request() override;
  explicit PROTOBUF_CONSTEXPR file_server_request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  file_server_request(const file_server_request& from);
  file_server_request(file_server_request&& from) noexcept
    : file_server_request() {
    *this = ::std::move(from);
  }

  inline file_server_request& operator=(const file_server_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline file_server_request& operator=(file_server_request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const file_server_request& default_instance() {
    return *internal_default_instance();
  }
  static inline const file_server_request* internal_default_instance() {
    return reinterpret_cast<const file_server_request*>(
               &_file_server_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(file_server_request& a, file_server_request& b) {
    a.Swap(&b);
  }
  inline void Swap(file_server_request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(file_server_request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  file_server_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<file_server_request>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const file_server_request& from);
  void MergeFrom(const file_server_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(file_server_request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "file_server_request";
  }
  protected:
  explicit file_server_request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // required string path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:file_server_request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// module_message

// required bytes data = 1;
inline bool module_message::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool module_message::has_data() const {
  return _internal_has_data();
}
inline void module_message::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& module_message::data() const {
  // @@protoc_insertion_point(field_get:module_message.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void module_message::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:module_message.data)
}
inline std::string* module_message::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:module_message.data)
  return _s;
}
inline const std::string& module_message::_internal_data() const {
  return _impl_.data_.Get();
}
inline void module_message::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* module_message::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* module_message::release_data() {
  // @@protoc_insertion_point(field_release:module_message.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void module_message::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:module_message.data)
}

// required int32 module_index = 2;
inline bool module_message::_internal_has_module_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool module_message::has_module_index() const {
  return _internal_has_module_index();
}
inline void module_message::clear_module_index() {
  _impl_.module_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t module_message::_internal_module_index() const {
  return _impl_.module_index_;
}
inline int32_t module_message::module_index() const {
  // @@protoc_insertion_point(field_get:module_message.module_index)
  return _internal_module_index();
}
inline void module_message::_internal_set_module_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.module_index_ = value;
}
inline void module_message::set_module_index(int32_t value) {
  _internal_set_module_index(value);
  // @@protoc_insertion_point(field_set:module_message.module_index)
}

// -------------------------------------------------------------------

// create_module

// required int32 type = 1;
inline bool create_module::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool create_module::has_type() const {
  return _internal_has_type();
}
inline void create_module::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t create_module::_internal_type() const {
  return _impl_.type_;
}
inline int32_t create_module::type() const {
  // @@protoc_insertion_point(field_get:create_module.type)
  return _internal_type();
}
inline void create_module::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void create_module::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:create_module.type)
}

// -------------------------------------------------------------------

// initialize_module

// required int32 module_index = 1;
inline bool initialize_module::_internal_has_module_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool initialize_module::has_module_index() const {
  return _internal_has_module_index();
}
inline void initialize_module::clear_module_index() {
  _impl_.module_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t initialize_module::_internal_module_index() const {
  return _impl_.module_index_;
}
inline int32_t initialize_module::module_index() const {
  // @@protoc_insertion_point(field_get:initialize_module.module_index)
  return _internal_module_index();
}
inline void initialize_module::_internal_set_module_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.module_index_ = value;
}
inline void initialize_module::set_module_index(int32_t value) {
  _internal_set_module_index(value);
  // @@protoc_insertion_point(field_set:initialize_module.module_index)
}

// optional bytes init_data = 2;
inline bool initialize_module::_internal_has_init_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool initialize_module::has_init_data() const {
  return _internal_has_init_data();
}
inline void initialize_module::clear_init_data() {
  _impl_.init_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& initialize_module::init_data() const {
  // @@protoc_insertion_point(field_get:initialize_module.init_data)
  return _internal_init_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void initialize_module::set_init_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.init_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:initialize_module.init_data)
}
inline std::string* initialize_module::mutable_init_data() {
  std::string* _s = _internal_mutable_init_data();
  // @@protoc_insertion_point(field_mutable:initialize_module.init_data)
  return _s;
}
inline const std::string& initialize_module::_internal_init_data() const {
  return _impl_.init_data_.Get();
}
inline void initialize_module::_internal_set_init_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.init_data_.Set(value, GetArenaForAllocation());
}
inline std::string* initialize_module::_internal_mutable_init_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.init_data_.Mutable(GetArenaForAllocation());
}
inline std::string* initialize_module::release_init_data() {
  // @@protoc_insertion_point(field_release:initialize_module.init_data)
  if (!_internal_has_init_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.init_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.init_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void initialize_module::set_allocated_init_data(std::string* init_data) {
  if (init_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.init_data_.SetAllocated(init_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.init_data_.IsDefault()) {
    _impl_.init_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:initialize_module.init_data)
}

// -------------------------------------------------------------------

// module_creation_result

// required bool failure = 1;
inline bool module_creation_result::_internal_has_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool module_creation_result::has_failure() const {
  return _internal_has_failure();
}
inline void module_creation_result::clear_failure() {
  _impl_.failure_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool module_creation_result::_internal_failure() const {
  return _impl_.failure_;
}
inline bool module_creation_result::failure() const {
  // @@protoc_insertion_point(field_get:module_creation_result.failure)
  return _internal_failure();
}
inline void module_creation_result::_internal_set_failure(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.failure_ = value;
}
inline void module_creation_result::set_failure(bool value) {
  _internal_set_failure(value);
  // @@protoc_insertion_point(field_set:module_creation_result.failure)
}

// optional int32 type = 2;
inline bool module_creation_result::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool module_creation_result::has_type() const {
  return _internal_has_type();
}
inline void module_creation_result::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t module_creation_result::_internal_type() const {
  return _impl_.type_;
}
inline int32_t module_creation_result::type() const {
  // @@protoc_insertion_point(field_get:module_creation_result.type)
  return _internal_type();
}
inline void module_creation_result::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void module_creation_result::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:module_creation_result.type)
}

// optional int32 index = 3;
inline bool module_creation_result::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool module_creation_result::has_index() const {
  return _internal_has_index();
}
inline void module_creation_result::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t module_creation_result::_internal_index() const {
  return _impl_.index_;
}
inline int32_t module_creation_result::index() const {
  // @@protoc_insertion_point(field_get:module_creation_result.index)
  return _internal_index();
}
inline void module_creation_result::_internal_set_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index_ = value;
}
inline void module_creation_result::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:module_creation_result.index)
}

// -------------------------------------------------------------------

// machine_information

// optional string username = 1;
inline bool machine_information::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool machine_information::has_username() const {
  return _internal_has_username();
}
inline void machine_information::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& machine_information::username() const {
  // @@protoc_insertion_point(field_get:machine_information.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void machine_information::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:machine_information.username)
}
inline std::string* machine_information::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:machine_information.username)
  return _s;
}
inline const std::string& machine_information::_internal_username() const {
  return _impl_.username_.Get();
}
inline void machine_information::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* machine_information::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* machine_information::release_username() {
  // @@protoc_insertion_point(field_release:machine_information.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void machine_information::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:machine_information.username)
}

// optional string localip = 2;
inline bool machine_information::_internal_has_localip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool machine_information::has_localip() const {
  return _internal_has_localip();
}
inline void machine_information::clear_localip() {
  _impl_.localip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& machine_information::localip() const {
  // @@protoc_insertion_point(field_get:machine_information.localip)
  return _internal_localip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void machine_information::set_localip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.localip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:machine_information.localip)
}
inline std::string* machine_information::mutable_localip() {
  std::string* _s = _internal_mutable_localip();
  // @@protoc_insertion_point(field_mutable:machine_information.localip)
  return _s;
}
inline const std::string& machine_information::_internal_localip() const {
  return _impl_.localip_.Get();
}
inline void machine_information::_internal_set_localip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.localip_.Set(value, GetArenaForAllocation());
}
inline std::string* machine_information::_internal_mutable_localip() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.localip_.Mutable(GetArenaForAllocation());
}
inline std::string* machine_information::release_localip() {
  // @@protoc_insertion_point(field_release:machine_information.localip)
  if (!_internal_has_localip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.localip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.localip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void machine_information::set_allocated_localip(std::string* localip) {
  if (localip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.localip_.SetAllocated(localip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localip_.IsDefault()) {
    _impl_.localip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:machine_information.localip)
}

// optional string externalip = 3;
inline bool machine_information::_internal_has_externalip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool machine_information::has_externalip() const {
  return _internal_has_externalip();
}
inline void machine_information::clear_externalip() {
  _impl_.externalip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& machine_information::externalip() const {
  // @@protoc_insertion_point(field_get:machine_information.externalip)
  return _internal_externalip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void machine_information::set_externalip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.externalip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:machine_information.externalip)
}
inline std::string* machine_information::mutable_externalip() {
  std::string* _s = _internal_mutable_externalip();
  // @@protoc_insertion_point(field_mutable:machine_information.externalip)
  return _s;
}
inline const std::string& machine_information::_internal_externalip() const {
  return _impl_.externalip_.Get();
}
inline void machine_information::_internal_set_externalip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.externalip_.Set(value, GetArenaForAllocation());
}
inline std::string* machine_information::_internal_mutable_externalip() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.externalip_.Mutable(GetArenaForAllocation());
}
inline std::string* machine_information::release_externalip() {
  // @@protoc_insertion_point(field_release:machine_information.externalip)
  if (!_internal_has_externalip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.externalip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.externalip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void machine_information::set_allocated_externalip(std::string* externalip) {
  if (externalip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.externalip_.SetAllocated(externalip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.externalip_.IsDefault()) {
    _impl_.externalip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:machine_information.externalip)
}

// -------------------------------------------------------------------

// screen_capture

// required int32 width = 1;
inline bool screen_capture::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool screen_capture::has_width() const {
  return _internal_has_width();
}
inline void screen_capture::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t screen_capture::_internal_width() const {
  return _impl_.width_;
}
inline int32_t screen_capture::width() const {
  // @@protoc_insertion_point(field_get:screen_capture.width)
  return _internal_width();
}
inline void screen_capture::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.width_ = value;
}
inline void screen_capture::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:screen_capture.width)
}

// required int32 height = 2;
inline bool screen_capture::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool screen_capture::has_height() const {
  return _internal_has_height();
}
inline void screen_capture::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t screen_capture::_internal_height() const {
  return _impl_.height_;
}
inline int32_t screen_capture::height() const {
  // @@protoc_insertion_point(field_get:screen_capture.height)
  return _internal_height();
}
inline void screen_capture::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_ = value;
}
inline void screen_capture::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:screen_capture.height)
}

// required bytes data = 3;
inline bool screen_capture::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool screen_capture::has_data() const {
  return _internal_has_data();
}
inline void screen_capture::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& screen_capture::data() const {
  // @@protoc_insertion_point(field_get:screen_capture.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void screen_capture::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:screen_capture.data)
}
inline std::string* screen_capture::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:screen_capture.data)
  return _s;
}
inline const std::string& screen_capture::_internal_data() const {
  return _impl_.data_.Get();
}
inline void screen_capture::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* screen_capture::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* screen_capture::release_data() {
  // @@protoc_insertion_point(field_release:screen_capture.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void screen_capture::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:screen_capture.data)
}

// -------------------------------------------------------------------

// screen_capture_startup

// required int32 ticks_between = 1;
inline bool screen_capture_startup::_internal_has_ticks_between() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool screen_capture_startup::has_ticks_between() const {
  return _internal_has_ticks_between();
}
inline void screen_capture_startup::clear_ticks_between() {
  _impl_.ticks_between_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t screen_capture_startup::_internal_ticks_between() const {
  return _impl_.ticks_between_;
}
inline int32_t screen_capture_startup::ticks_between() const {
  // @@protoc_insertion_point(field_get:screen_capture_startup.ticks_between)
  return _internal_ticks_between();
}
inline void screen_capture_startup::_internal_set_ticks_between(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ticks_between_ = value;
}
inline void screen_capture_startup::set_ticks_between(int32_t value) {
  _internal_set_ticks_between(value);
  // @@protoc_insertion_point(field_set:screen_capture_startup.ticks_between)
}

// -------------------------------------------------------------------

// task_startup

// required int32 task_number = 1;
inline bool task_startup::_internal_has_task_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool task_startup::has_task_number() const {
  return _internal_has_task_number();
}
inline void task_startup::clear_task_number() {
  _impl_.task_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t task_startup::_internal_task_number() const {
  return _impl_.task_number_;
}
inline int32_t task_startup::task_number() const {
  // @@protoc_insertion_point(field_get:task_startup.task_number)
  return _internal_task_number();
}
inline void task_startup::_internal_set_task_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.task_number_ = value;
}
inline void task_startup::set_task_number(int32_t value) {
  _internal_set_task_number(value);
  // @@protoc_insertion_point(field_set:task_startup.task_number)
}

// -------------------------------------------------------------------

// task_sig_end

// required int32 task_end = 1;
inline bool task_sig_end::_internal_has_task_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool task_sig_end::has_task_end() const {
  return _internal_has_task_end();
}
inline void task_sig_end::clear_task_end() {
  _impl_.task_end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t task_sig_end::_internal_task_end() const {
  return _impl_.task_end_;
}
inline int32_t task_sig_end::task_end() const {
  // @@protoc_insertion_point(field_get:task_sig_end.task_end)
  return _internal_task_end();
}
inline void task_sig_end::_internal_set_task_end(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.task_end_ = value;
}
inline void task_sig_end::set_task_end(int32_t value) {
  _internal_set_task_end(value);
  // @@protoc_insertion_point(field_set:task_sig_end.task_end)
}

// -------------------------------------------------------------------

// exit_process

// -------------------------------------------------------------------

// kill_instance

// -------------------------------------------------------------------

// server_notify_disconnect

// -------------------------------------------------------------------

// file_transfer_segment

// required string name = 1;
inline bool file_transfer_segment::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool file_transfer_segment::has_name() const {
  return _internal_has_name();
}
inline void file_transfer_segment::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& file_transfer_segment::name() const {
  // @@protoc_insertion_point(field_get:file_transfer_segment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void file_transfer_segment::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:file_transfer_segment.name)
}
inline std::string* file_transfer_segment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:file_transfer_segment.name)
  return _s;
}
inline const std::string& file_transfer_segment::_internal_name() const {
  return _impl_.name_.Get();
}
inline void file_transfer_segment::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* file_transfer_segment::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* file_transfer_segment::release_name() {
  // @@protoc_insertion_point(field_release:file_transfer_segment.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void file_transfer_segment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:file_transfer_segment.name)
}

// required int32 file_size = 2;
inline bool file_transfer_segment::_internal_has_file_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool file_transfer_segment::has_file_size() const {
  return _internal_has_file_size();
}
inline void file_transfer_segment::clear_file_size() {
  _impl_.file_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t file_transfer_segment::_internal_file_size() const {
  return _impl_.file_size_;
}
inline int32_t file_transfer_segment::file_size() const {
  // @@protoc_insertion_point(field_get:file_transfer_segment.file_size)
  return _internal_file_size();
}
inline void file_transfer_segment::_internal_set_file_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.file_size_ = value;
}
inline void file_transfer_segment::set_file_size(int32_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:file_transfer_segment.file_size)
}

// required int32 pos = 3;
inline bool file_transfer_segment::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool file_transfer_segment::has_pos() const {
  return _internal_has_pos();
}
inline void file_transfer_segment::clear_pos() {
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t file_transfer_segment::_internal_pos() const {
  return _impl_.pos_;
}
inline int32_t file_transfer_segment::pos() const {
  // @@protoc_insertion_point(field_get:file_transfer_segment.pos)
  return _internal_pos();
}
inline void file_transfer_segment::_internal_set_pos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pos_ = value;
}
inline void file_transfer_segment::set_pos(int32_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:file_transfer_segment.pos)
}

// required bytes data = 4;
inline bool file_transfer_segment::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool file_transfer_segment::has_data() const {
  return _internal_has_data();
}
inline void file_transfer_segment::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& file_transfer_segment::data() const {
  // @@protoc_insertion_point(field_get:file_transfer_segment.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void file_transfer_segment::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:file_transfer_segment.data)
}
inline std::string* file_transfer_segment::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:file_transfer_segment.data)
  return _s;
}
inline const std::string& file_transfer_segment::_internal_data() const {
  return _impl_.data_.Get();
}
inline void file_transfer_segment::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* file_transfer_segment::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* file_transfer_segment::release_data() {
  // @@protoc_insertion_point(field_release:file_transfer_segment.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void file_transfer_segment::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:file_transfer_segment.data)
}

// -------------------------------------------------------------------

// file_transfer_server_segment

// required .file_transfer_segment file = 1;
inline bool file_transfer_server_segment::_internal_has_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.file_ != nullptr);
  return value;
}
inline bool file_transfer_server_segment::has_file() const {
  return _internal_has_file();
}
inline void file_transfer_server_segment::clear_file() {
  if (_impl_.file_ != nullptr) _impl_.file_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::file_transfer_segment& file_transfer_server_segment::_internal_file() const {
  const ::file_transfer_segment* p = _impl_.file_;
  return p != nullptr ? *p : reinterpret_cast<const ::file_transfer_segment&>(
      ::_file_transfer_segment_default_instance_);
}
inline const ::file_transfer_segment& file_transfer_server_segment::file() const {
  // @@protoc_insertion_point(field_get:file_transfer_server_segment.file)
  return _internal_file();
}
inline void file_transfer_server_segment::unsafe_arena_set_allocated_file(
    ::file_transfer_segment* file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_);
  }
  _impl_.file_ = file;
  if (file) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:file_transfer_server_segment.file)
}
inline ::file_transfer_segment* file_transfer_server_segment::release_file() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::file_transfer_segment* temp = _impl_.file_;
  _impl_.file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::file_transfer_segment* file_transfer_server_segment::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:file_transfer_server_segment.file)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::file_transfer_segment* temp = _impl_.file_;
  _impl_.file_ = nullptr;
  return temp;
}
inline ::file_transfer_segment* file_transfer_server_segment::_internal_mutable_file() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.file_ == nullptr) {
    auto* p = CreateMaybeMessage<::file_transfer_segment>(GetArenaForAllocation());
    _impl_.file_ = p;
  }
  return _impl_.file_;
}
inline ::file_transfer_segment* file_transfer_server_segment::mutable_file() {
  ::file_transfer_segment* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:file_transfer_server_segment.file)
  return _msg;
}
inline void file_transfer_server_segment::set_allocated_file(::file_transfer_segment* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.file_ = file;
  // @@protoc_insertion_point(field_set_allocated:file_transfer_server_segment.file)
}

// required string drop_path = 2;
inline bool file_transfer_server_segment::_internal_has_drop_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool file_transfer_server_segment::has_drop_path() const {
  return _internal_has_drop_path();
}
inline void file_transfer_server_segment::clear_drop_path() {
  _impl_.drop_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& file_transfer_server_segment::drop_path() const {
  // @@protoc_insertion_point(field_get:file_transfer_server_segment.drop_path)
  return _internal_drop_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void file_transfer_server_segment::set_drop_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.drop_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:file_transfer_server_segment.drop_path)
}
inline std::string* file_transfer_server_segment::mutable_drop_path() {
  std::string* _s = _internal_mutable_drop_path();
  // @@protoc_insertion_point(field_mutable:file_transfer_server_segment.drop_path)
  return _s;
}
inline const std::string& file_transfer_server_segment::_internal_drop_path() const {
  return _impl_.drop_path_.Get();
}
inline void file_transfer_server_segment::_internal_set_drop_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.drop_path_.Set(value, GetArenaForAllocation());
}
inline std::string* file_transfer_server_segment::_internal_mutable_drop_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.drop_path_.Mutable(GetArenaForAllocation());
}
inline std::string* file_transfer_server_segment::release_drop_path() {
  // @@protoc_insertion_point(field_release:file_transfer_server_segment.drop_path)
  if (!_internal_has_drop_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.drop_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.drop_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void file_transfer_server_segment::set_allocated_drop_path(std::string* drop_path) {
  if (drop_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drop_path_.SetAllocated(drop_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.drop_path_.IsDefault()) {
    _impl_.drop_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:file_transfer_server_segment.drop_path)
}

// -------------------------------------------------------------------

// file_server_request

// required string path = 1;
inline bool file_server_request::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool file_server_request::has_path() const {
  return _internal_has_path();
}
inline void file_server_request::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& file_server_request::path() const {
  // @@protoc_insertion_point(field_get:file_server_request.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void file_server_request::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:file_server_request.path)
}
inline std::string* file_server_request::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:file_server_request.path)
  return _s;
}
inline const std::string& file_server_request::_internal_path() const {
  return _impl_.path_.Get();
}
inline void file_server_request::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* file_server_request::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* file_server_request::release_path() {
  // @@protoc_insertion_point(field_release:file_server_request.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void file_server_request::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:file_server_request.path)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_5fdefines_2fdiabolique_5fsystem_5fmessages_2eproto
